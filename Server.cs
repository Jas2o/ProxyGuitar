using System;
using System.Linq;
using System.Threading;
using System.Net;
using System.Net.Sockets;
using System.Diagnostics;

namespace ProxyGuitar {
    public static class Server {

        private static bool USE_MIDDLE = false;
        private static bool USE_MIDDLE_REPLY = true;

        private static Socket listener, handler;
        public static BaseController guitar;

        public static void StartListening() {
            guitar = new WiiGuitar();
            //guitar = new XboxController();
            //guitar = new PS3GH3();

            if (guitar.CanUse()) {
                Console.WriteLine("Guitar controller found: " + guitar.GetName());
            } else {
                Console.WriteLine("No usable guitar controller found to proxy.");
            }

            //--

            IPHostEntry ipHostInfo = Dns.GetHostEntry("localhost");
            IPAddress ipAddress = ipHostInfo.AddressList[1];
            IPEndPoint localEndPoint = new IPEndPoint(IPAddress.Any, 3240); //ipAddress, 3240
            listener = new Socket(ipAddress.AddressFamily, SocketType.Stream, ProtocolType.Tcp);

            listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true);
            listener.NoDelay = true;
            listener.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.KeepAlive, true);
            listener.Bind(localEndPoint);
            listener.Listen(1);

            int clientSocket = 9101;
            bool middle_success = false;

            while (true) {
                Console.WriteLine("Waiting for a connection...");
                handler = listener.Accept(); //This blocks until connected

                Console.WriteLine("Client connect");

                NetworkStream clientStream = null;
                if (USE_MIDDLE) {
                    try {
                        Console.WriteLine("Connecting to other server...");
                        //Console.WriteLine(clientSocket);

                        IPAddress clientIP = Dns.GetHostAddresses("192.168.15.7")[0];
                        IPEndPoint clientEP = new IPEndPoint(clientIP, clientSocket++);

                        IPAddress remoteIP = Dns.GetHostAddresses("192.168.15.4")[0];
                        IPEndPoint remoteEP = new IPEndPoint(remoteIP, 3240);

                        TcpClient client = new TcpClient(clientEP);
                        client.Connect(remoteEP);
                        clientStream = client.GetStream();
                        middle_success = true;
                        Console.WriteLine("Connect to other server!");
                    } catch (Exception ex) {
                        if (!middle_success)
                            clientSocket++;
                    }
                }

                bool loop = (USE_MIDDLE == false) || (clientStream != null);
                bool attached = false;

                while (loop && handler != null) {
                    if (attached) {

                        if (handler.Available < 48) {
                            Thread.Sleep(20);
                            continue;
                        }

                        byte[] bytes = new byte[48];
                        int bytesRec = handler.Receive(bytes);

                        if (bytesRec > 0) {
                            byte[] rec = GTL.SubArray(bytes, bytesRec);

                            USBIP_CMD_SUBMIT cmd = new USBIP_CMD_SUBMIT(rec);
                            USBIP_RET_SUBMIT submit = USBIP.HandleRequest(ref cmd);

                            byte[] recPhone = null;
                            if (USE_MIDDLE) {
                                clientStream.Write(rec, 0, bytesRec);
                                byte[] clientbytes = new byte[1024];
                                int bytesRecPhone = clientStream.Read(clientbytes, 0, clientbytes.Length);
                                recPhone = GTL.SubArray(clientbytes, bytesRecPhone);
                            }

                            if (USE_MIDDLE && USE_MIDDLE_REPLY) {
                                if (recPhone != null) {
                                    byte[] reply = submit.ToBytes();
                                    if (!reply.SequenceEqual(recPhone)) {
                                        Console.WriteLine("DOESN'T MATCH");
                                        Console.WriteLine("bmReqType: {0:X2} | bReq: {1:X2} | wIndex: {2:X2} | wValue: {3:X2} | wLength: {4:X2}", cmd.urb.bmRequestType, cmd.urb.bRequest, cmd.urb.wIndex, cmd.urb.wValue, cmd.urb.wLength);
                                        Console.WriteLine("<PHONE< " + GTL.ByteArrayToString(recPhone, " "));
                                        Console.WriteLine("<   ME< " + GTL.ByteArrayToString(reply, " "));
                                        Console.WriteLine("");
                                    }

                                    handler.Send(recPhone);
                                }
                            } else {
                                if (submit.ReadyToSend) {
                                    byte[] reply = submit.ToBytes();
                                    handler.Send(reply);
                                    
                                    //Console.WriteLine("<< " + GTL.ByteArrayToString(reply, " "));
                                } else {
                                    Console.WriteLine("bmReqType: {0:X2} | bReq: {1:X2} | wIndex: {2:X2} | wValue: {3:X2} | wLength: {4:X2}", cmd.urb.bmRequestType, cmd.urb.bRequest, cmd.urb.wIndex, cmd.urb.wValue, cmd.urb.wLength);
                                    Console.WriteLine("Stuck on: " + GTL.ByteArrayToString(rec, " "));
                                }
                            }
                        }
                    } else {
                        byte[] bytes = new byte[1024];
                        int bytesRec = handler.Receive(bytes);

                        if (bytesRec > 0) {
                            byte[] rec = GTL.SubArray(bytes, bytesRec);

                            if (USE_MIDDLE) {
                                clientStream.Write(rec, 0, bytesRec);
                                byte[] clientbytes = new byte[1024];
                                int bytesRecPhone = clientStream.Read(clientbytes, 0, clientbytes.Length);
                                byte[] recPhone = GTL.SubArray(clientbytes, bytesRecPhone);
                            }

                            //Console.WriteLine(">> " + GTL.ByteArrayToString(rec, " "));
#region Not Attached
                            int version = GTL.ReadInt(rec, 0, 2, true);
                            int command = GTL.ReadInt(rec, 2, 2, true);

                            if (command == 0x8005) {
                                byte[] reply = new byte[] { 0x01, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x62, 0x75, 0x73, 0x2f, 0x75, 0x73, 0x62, 0x2f, 0x30, 0x30, 0x31, 0x2f, 0x30, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x2d, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x12, 0xba, 0x02, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x00, 0x00, 0x00 };
                                handler.Send(reply);
                                //Console.WriteLine("<< " + GTL.ByteArrayToString(reply, " "));
                                loop = false;
                            } else if (command == 0x8003) { //If you don't get this, you didn't send the same busid to the server
                                if (bytesRec == 40) {
                                    byte[] reply = new byte[] { 0x01, 0x06, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x2f, 0x64, 0x65, 0x76, 0x2f, 0x62, 0x75, 0x73, 0x2f, 0x75, 0x73, 0x62, 0x2f, 0x30, 0x30, 0x31, 0x2f, 0x30, 0x30, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x2d, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x02, 0x12, 0xba, 0x02, 0x00, 0x03, 0x13, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01 };
                                    handler.Send(reply);
                                    //Console.WriteLine("<< " + GTL.ByteArrayToString(reply, " "));
                                    attached = true;
                                }
                            }
#endregion
                        }
                    }
                }

                if (handler != null) {
                    handler.Shutdown(SocketShutdown.Both);
                    handler.Close();
                    handler = null;
                }
            }

        }

        public static void Shutdown() {
            if (listener != null) {
                listener.Close();

                if (handler != null) {
                    handler.Shutdown(SocketShutdown.Both);
                    handler.Close();
                    handler = null;
                }
            }
        }
    }
}
